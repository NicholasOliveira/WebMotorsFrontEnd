{"ast":null,"code":"/** Creates a SentryRequest from an event. */\nexport function sessionToSentryRequest(session, api) {\n  var envelopeHeaders = JSON.stringify({\n    sent_at: new Date().toISOString()\n  });\n  var itemHeaders = JSON.stringify({\n    type: 'session'\n  });\n  return {\n    body: envelopeHeaders + \"\\n\" + itemHeaders + \"\\n\" + JSON.stringify(session),\n    type: 'session',\n    url: api.getEnvelopeEndpointWithUrlEncodedAuth()\n  };\n}\n/** Creates a SentryRequest from an event. */\n\nexport function eventToSentryRequest(event, api) {\n  var useEnvelope = event.type === 'transaction';\n  var req = {\n    body: JSON.stringify(event),\n    type: event.type || 'event',\n    url: useEnvelope ? api.getEnvelopeEndpointWithUrlEncodedAuth() : api.getStoreEndpointWithUrlEncodedAuth()\n  }; // https://develop.sentry.dev/sdk/envelopes/\n  // Since we don't need to manipulate envelopes nor store them, there is no\n  // exported concept of an Envelope with operations including serialization and\n  // deserialization. Instead, we only implement a minimal subset of the spec to\n  // serialize events inline here.\n\n  if (useEnvelope) {\n    var envelopeHeaders = JSON.stringify({\n      event_id: event.event_id,\n      // We need to add * 1000 since we divide it by 1000 by default but JS works with ms precision\n      // The reason we use timestampWithMs here is that all clocks across the SDK use the same clock\n      sent_at: new Date().toISOString()\n    });\n    var itemHeaders = JSON.stringify({\n      type: event.type\n    }); // The trailing newline is optional. We intentionally don't send it to avoid\n    // sending unnecessary bytes.\n    //\n    // const envelope = `${envelopeHeaders}\\n${itemHeaders}\\n${req.body}\\n`;\n\n    var envelope = envelopeHeaders + \"\\n\" + itemHeaders + \"\\n\" + req.body;\n    req.body = envelope;\n  }\n\n  return req;\n}","map":{"version":3,"sources":["../src/request.ts"],"names":[],"mappings":"AAIA;AACA,OAAM,SAAU,sBAAV,CAAiC,OAAjC,EAAmD,GAAnD,EAA2D;AAC/D,MAAM,eAAe,GAAG,IAAI,CAAC,SAAL,CAAe;AACrC,IAAA,OAAO,EAAE,IAAI,IAAJ,GAAW,WAAX;AAD4B,GAAf,CAAxB;AAGA,MAAM,WAAW,GAAG,IAAI,CAAC,SAAL,CAAe;AACjC,IAAA,IAAI,EAAE;AAD2B,GAAf,CAApB;AAIA,SAAO;AACL,IAAA,IAAI,EAAK,eAAe,GAAA,IAAf,GAAoB,WAApB,GAA+B,IAA/B,GAAoC,IAAI,CAAC,SAAL,CAAe,OAAf,CADxC;AAEL,IAAA,IAAI,EAAE,SAFD;AAGL,IAAA,GAAG,EAAE,GAAG,CAAC,qCAAJ;AAHA,GAAP;AAKD;AAED;;AACA,OAAM,SAAU,oBAAV,CAA+B,KAA/B,EAA6C,GAA7C,EAAqD;AACzD,MAAM,WAAW,GAAG,KAAK,CAAC,IAAN,KAAe,aAAnC;AAEA,MAAM,GAAG,GAAkB;AACzB,IAAA,IAAI,EAAE,IAAI,CAAC,SAAL,CAAe,KAAf,CADmB;AAEzB,IAAA,IAAI,EAAE,KAAK,CAAC,IAAN,IAAc,OAFK;AAGzB,IAAA,GAAG,EAAE,WAAW,GAAG,GAAG,CAAC,qCAAJ,EAAH,GAAiD,GAAG,CAAC,kCAAJ;AAHxC,GAA3B,CAHyD,CASzD;AAEA;AACA;AACA;AACA;;AACA,MAAI,WAAJ,EAAiB;AACf,QAAM,eAAe,GAAG,IAAI,CAAC,SAAL,CAAe;AACrC,MAAA,QAAQ,EAAE,KAAK,CAAC,QADqB;AAErC;AACA;AACA,MAAA,OAAO,EAAE,IAAI,IAAJ,GAAW,WAAX;AAJ4B,KAAf,CAAxB;AAMA,QAAM,WAAW,GAAG,IAAI,CAAC,SAAL,CAAe;AACjC,MAAA,IAAI,EAAE,KAAK,CAAC;AADqB,KAAf,CAApB,CAPe,CAuBf;AACA;AACA;AACA;;AACA,QAAM,QAAQ,GAAM,eAAe,GAAA,IAAf,GAAoB,WAApB,GAA+B,IAA/B,GAAoC,GAAG,CAAC,IAA5D;AACA,IAAA,GAAG,CAAC,IAAJ,GAAW,QAAX;AACD;;AAED,SAAO,GAAP;AACD","sourcesContent":["import { Event, SentryRequest, Session } from '@sentry/types';\n\nimport { API } from './api';\n\n/** Creates a SentryRequest from an event. */\nexport function sessionToSentryRequest(session: Session, api: API): SentryRequest {\n  const envelopeHeaders = JSON.stringify({\n    sent_at: new Date().toISOString(),\n  });\n  const itemHeaders = JSON.stringify({\n    type: 'session',\n  });\n\n  return {\n    body: `${envelopeHeaders}\\n${itemHeaders}\\n${JSON.stringify(session)}`,\n    type: 'session',\n    url: api.getEnvelopeEndpointWithUrlEncodedAuth(),\n  };\n}\n\n/** Creates a SentryRequest from an event. */\nexport function eventToSentryRequest(event: Event, api: API): SentryRequest {\n  const useEnvelope = event.type === 'transaction';\n\n  const req: SentryRequest = {\n    body: JSON.stringify(event),\n    type: event.type || 'event',\n    url: useEnvelope ? api.getEnvelopeEndpointWithUrlEncodedAuth() : api.getStoreEndpointWithUrlEncodedAuth(),\n  };\n\n  // https://develop.sentry.dev/sdk/envelopes/\n\n  // Since we don't need to manipulate envelopes nor store them, there is no\n  // exported concept of an Envelope with operations including serialization and\n  // deserialization. Instead, we only implement a minimal subset of the spec to\n  // serialize events inline here.\n  if (useEnvelope) {\n    const envelopeHeaders = JSON.stringify({\n      event_id: event.event_id,\n      // We need to add * 1000 since we divide it by 1000 by default but JS works with ms precision\n      // The reason we use timestampWithMs here is that all clocks across the SDK use the same clock\n      sent_at: new Date().toISOString(),\n    });\n    const itemHeaders = JSON.stringify({\n      type: event.type,\n      // The content-type is assumed to be 'application/json' and not part of\n      // the current spec for transaction items, so we don't bloat the request\n      // body with it.\n      //\n      // content_type: 'application/json',\n      //\n      // The length is optional. It must be the number of bytes in req.Body\n      // encoded as UTF-8. Since the server can figure this out and would\n      // otherwise refuse events that report the length incorrectly, we decided\n      // not to send the length to avoid problems related to reporting the wrong\n      // size and to reduce request body size.\n      //\n      // length: new TextEncoder().encode(req.body).length,\n    });\n    // The trailing newline is optional. We intentionally don't send it to avoid\n    // sending unnecessary bytes.\n    //\n    // const envelope = `${envelopeHeaders}\\n${itemHeaders}\\n${req.body}\\n`;\n    const envelope = `${envelopeHeaders}\\n${itemHeaders}\\n${req.body}`;\n    req.body = envelope;\n  }\n\n  return req;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}