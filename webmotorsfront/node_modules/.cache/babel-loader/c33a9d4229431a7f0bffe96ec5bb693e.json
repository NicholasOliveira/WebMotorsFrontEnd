{"ast":null,"code":"import { __extends, __values } from \"tslib\";\nimport { logger, timestampWithMs } from '@sentry/utils';\nimport { SpanRecorder } from './span';\nimport { SpanStatus } from './spanstatus';\nimport { Transaction } from './transaction';\nexport var DEFAULT_IDLE_TIMEOUT = 1000;\n/**\n * @inheritDoc\n */\n\nvar IdleTransactionSpanRecorder =\n/** @class */\nfunction (_super) {\n  __extends(IdleTransactionSpanRecorder, _super);\n\n  function IdleTransactionSpanRecorder(_pushActivity, _popActivity, transactionSpanId, maxlen) {\n    if (transactionSpanId === void 0) {\n      transactionSpanId = '';\n    }\n\n    var _this = _super.call(this, maxlen) || this;\n\n    _this._pushActivity = _pushActivity;\n    _this._popActivity = _popActivity;\n    _this.transactionSpanId = transactionSpanId;\n    return _this;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  IdleTransactionSpanRecorder.prototype.add = function (span) {\n    var _this = this; // We should make sure we do not push and pop activities for\n    // the transaction that this span recorder belongs to.\n\n\n    if (span.spanId !== this.transactionSpanId) {\n      // We patch span.finish() to pop an activity after setting an endTimestamp.\n      span.finish = function (endTimestamp) {\n        span.endTimestamp = typeof endTimestamp === 'number' ? endTimestamp : timestampWithMs();\n\n        _this._popActivity(span.spanId);\n      }; // We should only push new activities if the span does not have an end timestamp.\n\n\n      if (span.endTimestamp === undefined) {\n        this._pushActivity(span.spanId);\n      }\n    }\n\n    _super.prototype.add.call(this, span);\n  };\n\n  return IdleTransactionSpanRecorder;\n}(SpanRecorder);\n\nexport { IdleTransactionSpanRecorder };\n/**\n * An IdleTransaction is a transaction that automatically finishes. It does this by tracking child spans as activities.\n * You can have multiple IdleTransactions active, but if the `onScope` option is specified, the idle transaction will\n * put itself on the scope on creation.\n */\n\nvar IdleTransaction =\n/** @class */\nfunction (_super) {\n  __extends(IdleTransaction, _super);\n\n  function IdleTransaction(transactionContext, _idleHub, // The time to wait in ms until the idle transaction will be finished. Default: 1000\n  _idleTimeout, // If an idle transaction should be put itself on and off the scope automatically.\n  _onScope) {\n    if (_idleTimeout === void 0) {\n      _idleTimeout = DEFAULT_IDLE_TIMEOUT;\n    }\n\n    if (_onScope === void 0) {\n      _onScope = false;\n    }\n\n    var _this = _super.call(this, transactionContext, _idleHub) || this;\n\n    _this._idleHub = _idleHub;\n    _this._idleTimeout = _idleTimeout;\n    _this._onScope = _onScope; // Activities store a list of active spans\n\n    _this.activities = {}; // Stores reference to the timeout that calls _beat().\n\n    _this._heartbeatTimer = 0; // Amount of times heartbeat has counted. Will cause transaction to finish after 3 beats.\n\n    _this._heartbeatCounter = 0; // We should not use heartbeat if we finished a transaction\n\n    _this._finished = false;\n    _this._beforeFinishCallbacks = [];\n\n    if (_idleHub && _onScope) {\n      // There should only be one active transaction on the scope\n      clearActiveTransaction(_idleHub); // We set the transaction here on the scope so error events pick up the trace\n      // context and attach it to the error.\n\n      logger.log(\"Setting idle transaction on scope. Span ID: \" + _this.spanId);\n\n      _idleHub.configureScope(function (scope) {\n        return scope.setSpan(_this);\n      });\n    }\n\n    return _this;\n  }\n  /** {@inheritDoc} */\n\n\n  IdleTransaction.prototype.finish = function (endTimestamp) {\n    var e_1, _a;\n\n    var _this = this;\n\n    if (endTimestamp === void 0) {\n      endTimestamp = timestampWithMs();\n    }\n\n    this._finished = true;\n    this.activities = {};\n\n    if (this.spanRecorder) {\n      logger.log('[Tracing] finishing IdleTransaction', new Date(endTimestamp * 1000).toISOString(), this.op);\n\n      try {\n        for (var _b = __values(this._beforeFinishCallbacks), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var callback = _c.value;\n          callback(this, endTimestamp);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      this.spanRecorder.spans = this.spanRecorder.spans.filter(function (span) {\n        // If we are dealing with the transaction itself, we just return it\n        if (span.spanId === _this.spanId) {\n          return true;\n        } // We cancel all pending spans with status \"cancelled\" to indicate the idle transaction was finished early\n\n\n        if (!span.endTimestamp) {\n          span.endTimestamp = endTimestamp;\n          span.setStatus(SpanStatus.Cancelled);\n          logger.log('[Tracing] cancelling span since transaction ended early', JSON.stringify(span, undefined, 2));\n        }\n\n        var keepSpan = span.startTimestamp < endTimestamp;\n\n        if (!keepSpan) {\n          logger.log('[Tracing] discarding Span since it happened after Transaction was finished', JSON.stringify(span, undefined, 2));\n        }\n\n        return keepSpan;\n      }); // this._onScope is true if the transaction was previously on the scope.\n\n      if (this._onScope) {\n        clearActiveTransaction(this._idleHub);\n      }\n\n      logger.log('[Tracing] flushing IdleTransaction');\n    } else {\n      logger.log('[Tracing] No active IdleTransaction');\n    }\n\n    return _super.prototype.finish.call(this, endTimestamp);\n  };\n  /**\n   * Register a callback function that gets excecuted before the transaction finishes.\n   * Useful for cleanup or if you want to add any additional spans based on current context.\n   *\n   * This is exposed because users have no other way of running something before an idle transaction\n   * finishes.\n   */\n\n\n  IdleTransaction.prototype.registerBeforeFinishCallback = function (callback) {\n    this._beforeFinishCallbacks.push(callback);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  IdleTransaction.prototype.initSpanRecorder = function (maxlen) {\n    var _this = this;\n\n    if (!this.spanRecorder) {\n      this._initTimeout = setTimeout(function () {\n        if (!_this._finished) {\n          _this.finish();\n        }\n      }, this._idleTimeout);\n\n      var pushActivity = function (id) {\n        if (_this._finished) {\n          return;\n        }\n\n        _this._pushActivity(id);\n      };\n\n      var popActivity = function (id) {\n        if (_this._finished) {\n          return;\n        }\n\n        _this._popActivity(id);\n      };\n\n      this.spanRecorder = new IdleTransactionSpanRecorder(pushActivity, popActivity, this.spanId, maxlen); // Start heartbeat so that transactions do not run forever.\n\n      logger.log('Starting heartbeat');\n\n      this._pingHeartbeat();\n    }\n\n    this.spanRecorder.add(this);\n  };\n  /**\n   * Start tracking a specific activity.\n   * @param spanId The span id that represents the activity\n   */\n\n\n  IdleTransaction.prototype._pushActivity = function (spanId) {\n    if (this._initTimeout) {\n      clearTimeout(this._initTimeout);\n      this._initTimeout = undefined;\n    }\n\n    logger.log(\"[Tracing] pushActivity: \" + spanId);\n    this.activities[spanId] = true;\n    logger.log('[Tracing] new activities count', Object.keys(this.activities).length);\n  };\n  /**\n   * Remove an activity from usage\n   * @param spanId The span id that represents the activity\n   */\n\n\n  IdleTransaction.prototype._popActivity = function (spanId) {\n    var _this = this;\n\n    if (this.activities[spanId]) {\n      logger.log(\"[Tracing] popActivity \" + spanId); // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n\n      delete this.activities[spanId];\n      logger.log('[Tracing] new activities count', Object.keys(this.activities).length);\n    }\n\n    if (Object.keys(this.activities).length === 0) {\n      var timeout = this._idleTimeout; // We need to add the timeout here to have the real endtimestamp of the transaction\n      // Remember timestampWithMs is in seconds, timeout is in ms\n\n      var end_1 = timestampWithMs() + timeout / 1000;\n      setTimeout(function () {\n        if (!_this._finished) {\n          _this.finish(end_1);\n        }\n      }, timeout);\n    }\n  };\n  /**\n   * Checks when entries of this.activities are not changing for 3 beats.\n   * If this occurs we finish the transaction.\n   */\n\n\n  IdleTransaction.prototype._beat = function () {\n    clearTimeout(this._heartbeatTimer); // We should not be running heartbeat if the idle transaction is finished.\n\n    if (this._finished) {\n      return;\n    }\n\n    var keys = Object.keys(this.activities);\n    var heartbeatString = keys.length ? keys.reduce(function (prev, current) {\n      return prev + current;\n    }) : '';\n\n    if (heartbeatString === this._prevHeartbeatString) {\n      this._heartbeatCounter += 1;\n    } else {\n      this._heartbeatCounter = 1;\n    }\n\n    this._prevHeartbeatString = heartbeatString;\n\n    if (this._heartbeatCounter >= 3) {\n      logger.log(\"[Tracing] Transaction finished because of no change for 3 heart beats\");\n      this.setStatus(SpanStatus.DeadlineExceeded);\n      this.setTag('heartbeat', 'failed');\n      this.finish();\n    } else {\n      this._pingHeartbeat();\n    }\n  };\n  /**\n   * Pings the heartbeat\n   */\n\n\n  IdleTransaction.prototype._pingHeartbeat = function () {\n    var _this = this;\n\n    logger.log(\"pinging Heartbeat -> current counter: \" + this._heartbeatCounter);\n    this._heartbeatTimer = setTimeout(function () {\n      _this._beat();\n    }, 5000);\n  };\n\n  return IdleTransaction;\n}(Transaction);\n\nexport { IdleTransaction };\n/**\n * Reset active transaction on scope\n */\n\nfunction clearActiveTransaction(hub) {\n  if (hub) {\n    var scope = hub.getScope();\n\n    if (scope) {\n      var transaction = scope.getTransaction();\n\n      if (transaction) {\n        scope.setSpan(undefined);\n      }\n    }\n  }\n}","map":{"version":3,"sources":["../src/idletransaction.ts"],"names":[],"mappings":"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","sourcesContent":["import { Hub } from '@sentry/hub';\nimport { TransactionContext } from '@sentry/types';\nimport { logger, timestampWithMs } from '@sentry/utils';\n\nimport { Span, SpanRecorder } from './span';\nimport { SpanStatus } from './spanstatus';\nimport { Transaction } from './transaction';\n\nexport const DEFAULT_IDLE_TIMEOUT = 1000;\n\n/**\n * @inheritDoc\n */\nexport class IdleTransactionSpanRecorder extends SpanRecorder {\n  public constructor(\n    private readonly _pushActivity: (id: string) => void,\n    private readonly _popActivity: (id: string) => void,\n    public transactionSpanId: string = '',\n    maxlen?: number,\n  ) {\n    super(maxlen);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public add(span: Span): void {\n    // We should make sure we do not push and pop activities for\n    // the transaction that this span recorder belongs to.\n    if (span.spanId !== this.transactionSpanId) {\n      // We patch span.finish() to pop an activity after setting an endTimestamp.\n      span.finish = (endTimestamp?: number) => {\n        span.endTimestamp = typeof endTimestamp === 'number' ? endTimestamp : timestampWithMs();\n        this._popActivity(span.spanId);\n      };\n\n      // We should only push new activities if the span does not have an end timestamp.\n      if (span.endTimestamp === undefined) {\n        this._pushActivity(span.spanId);\n      }\n    }\n\n    super.add(span);\n  }\n}\n\nexport type BeforeFinishCallback = (transactionSpan: IdleTransaction, endTimestamp: number) => void;\n\n/**\n * An IdleTransaction is a transaction that automatically finishes. It does this by tracking child spans as activities.\n * You can have multiple IdleTransactions active, but if the `onScope` option is specified, the idle transaction will\n * put itself on the scope on creation.\n */\nexport class IdleTransaction extends Transaction {\n  // Activities store a list of active spans\n  public activities: Record<string, boolean> = {};\n\n  // Stores reference to the timeout that calls _beat().\n  private _heartbeatTimer: number = 0;\n\n  // Track state of activities in previous heartbeat\n  private _prevHeartbeatString: string | undefined;\n\n  // Amount of times heartbeat has counted. Will cause transaction to finish after 3 beats.\n  private _heartbeatCounter: number = 0;\n\n  // We should not use heartbeat if we finished a transaction\n  private _finished: boolean = false;\n\n  private readonly _beforeFinishCallbacks: BeforeFinishCallback[] = [];\n\n  // If a transaction is created and no activities are added, we want to make sure that\n  // it times out properly. This is cleared and not used when activities are added.\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private _initTimeout: any;\n\n  public constructor(\n    transactionContext: TransactionContext,\n    private readonly _idleHub?: Hub,\n    // The time to wait in ms until the idle transaction will be finished. Default: 1000\n    private readonly _idleTimeout: number = DEFAULT_IDLE_TIMEOUT,\n    // If an idle transaction should be put itself on and off the scope automatically.\n    private readonly _onScope: boolean = false,\n  ) {\n    super(transactionContext, _idleHub);\n\n    if (_idleHub && _onScope) {\n      // There should only be one active transaction on the scope\n      clearActiveTransaction(_idleHub);\n\n      // We set the transaction here on the scope so error events pick up the trace\n      // context and attach it to the error.\n      logger.log(`Setting idle transaction on scope. Span ID: ${this.spanId}`);\n      _idleHub.configureScope(scope => scope.setSpan(this));\n    }\n  }\n\n  /** {@inheritDoc} */\n  public finish(endTimestamp: number = timestampWithMs()): string | undefined {\n    this._finished = true;\n    this.activities = {};\n\n    if (this.spanRecorder) {\n      logger.log('[Tracing] finishing IdleTransaction', new Date(endTimestamp * 1000).toISOString(), this.op);\n\n      for (const callback of this._beforeFinishCallbacks) {\n        callback(this, endTimestamp);\n      }\n\n      this.spanRecorder.spans = this.spanRecorder.spans.filter((span: Span) => {\n        // If we are dealing with the transaction itself, we just return it\n        if (span.spanId === this.spanId) {\n          return true;\n        }\n\n        // We cancel all pending spans with status \"cancelled\" to indicate the idle transaction was finished early\n        if (!span.endTimestamp) {\n          span.endTimestamp = endTimestamp;\n          span.setStatus(SpanStatus.Cancelled);\n          logger.log('[Tracing] cancelling span since transaction ended early', JSON.stringify(span, undefined, 2));\n        }\n\n        const keepSpan = span.startTimestamp < endTimestamp;\n        if (!keepSpan) {\n          logger.log(\n            '[Tracing] discarding Span since it happened after Transaction was finished',\n            JSON.stringify(span, undefined, 2),\n          );\n        }\n        return keepSpan;\n      });\n\n      // this._onScope is true if the transaction was previously on the scope.\n      if (this._onScope) {\n        clearActiveTransaction(this._idleHub);\n      }\n\n      logger.log('[Tracing] flushing IdleTransaction');\n    } else {\n      logger.log('[Tracing] No active IdleTransaction');\n    }\n\n    return super.finish(endTimestamp);\n  }\n\n  /**\n   * Register a callback function that gets excecuted before the transaction finishes.\n   * Useful for cleanup or if you want to add any additional spans based on current context.\n   *\n   * This is exposed because users have no other way of running something before an idle transaction\n   * finishes.\n   */\n  public registerBeforeFinishCallback(callback: BeforeFinishCallback): void {\n    this._beforeFinishCallbacks.push(callback);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public initSpanRecorder(maxlen?: number): void {\n    if (!this.spanRecorder) {\n      this._initTimeout = setTimeout(() => {\n        if (!this._finished) {\n          this.finish();\n        }\n      }, this._idleTimeout);\n\n      const pushActivity = (id: string): void => {\n        if (this._finished) {\n          return;\n        }\n        this._pushActivity(id);\n      };\n      const popActivity = (id: string): void => {\n        if (this._finished) {\n          return;\n        }\n        this._popActivity(id);\n      };\n\n      this.spanRecorder = new IdleTransactionSpanRecorder(pushActivity, popActivity, this.spanId, maxlen);\n\n      // Start heartbeat so that transactions do not run forever.\n      logger.log('Starting heartbeat');\n      this._pingHeartbeat();\n    }\n    this.spanRecorder.add(this);\n  }\n\n  /**\n   * Start tracking a specific activity.\n   * @param spanId The span id that represents the activity\n   */\n  private _pushActivity(spanId: string): void {\n    if (this._initTimeout) {\n      clearTimeout(this._initTimeout);\n      this._initTimeout = undefined;\n    }\n    logger.log(`[Tracing] pushActivity: ${spanId}`);\n    this.activities[spanId] = true;\n    logger.log('[Tracing] new activities count', Object.keys(this.activities).length);\n  }\n\n  /**\n   * Remove an activity from usage\n   * @param spanId The span id that represents the activity\n   */\n  private _popActivity(spanId: string): void {\n    if (this.activities[spanId]) {\n      logger.log(`[Tracing] popActivity ${spanId}`);\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete this.activities[spanId];\n      logger.log('[Tracing] new activities count', Object.keys(this.activities).length);\n    }\n\n    if (Object.keys(this.activities).length === 0) {\n      const timeout = this._idleTimeout;\n      // We need to add the timeout here to have the real endtimestamp of the transaction\n      // Remember timestampWithMs is in seconds, timeout is in ms\n      const end = timestampWithMs() + timeout / 1000;\n\n      setTimeout(() => {\n        if (!this._finished) {\n          this.finish(end);\n        }\n      }, timeout);\n    }\n  }\n\n  /**\n   * Checks when entries of this.activities are not changing for 3 beats.\n   * If this occurs we finish the transaction.\n   */\n  private _beat(): void {\n    clearTimeout(this._heartbeatTimer);\n    // We should not be running heartbeat if the idle transaction is finished.\n    if (this._finished) {\n      return;\n    }\n\n    const keys = Object.keys(this.activities);\n    const heartbeatString = keys.length ? keys.reduce((prev: string, current: string) => prev + current) : '';\n\n    if (heartbeatString === this._prevHeartbeatString) {\n      this._heartbeatCounter += 1;\n    } else {\n      this._heartbeatCounter = 1;\n    }\n\n    this._prevHeartbeatString = heartbeatString;\n\n    if (this._heartbeatCounter >= 3) {\n      logger.log(`[Tracing] Transaction finished because of no change for 3 heart beats`);\n      this.setStatus(SpanStatus.DeadlineExceeded);\n      this.setTag('heartbeat', 'failed');\n      this.finish();\n    } else {\n      this._pingHeartbeat();\n    }\n  }\n\n  /**\n   * Pings the heartbeat\n   */\n  private _pingHeartbeat(): void {\n    logger.log(`pinging Heartbeat -> current counter: ${this._heartbeatCounter}`);\n    this._heartbeatTimer = (setTimeout(() => {\n      this._beat();\n    }, 5000) as unknown) as number;\n  }\n}\n\n/**\n * Reset active transaction on scope\n */\nfunction clearActiveTransaction(hub?: Hub): void {\n  if (hub) {\n    const scope = hub.getScope();\n    if (scope) {\n      const transaction = scope.getTransaction();\n      if (transaction) {\n        scope.setSpan(undefined);\n      }\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}